import{util as e}from"../../util/index.min.js";import t from"https://cdn.jsdelivr.net/npm/lodash-es/throttle.min.js";const n={observeDOMChanges:(()=>{const t=new WeakMap;return(o,r=document.body||document.documentElement,{timeout:c=6e5,throttleInterval:l=500}={})=>{if(!t.has(r)){const e=[],n=new MutationObserver(((t,n)=>{(()=>{if(e.length>0)for(const{cb:o,removeCb:r}of e)o({mutations:t,observer:n,disconnect:()=>r(n)})})()})),o=()=>{n.observe(r,{attributes:!0,childList:!0,subtree:!0})};t.set(r,{observer:n,callbackQueue:e}),o()}const{observer:s,callbackQueue:i}=t.get(r),a={cb:n.throttleWithTail(o,l),callbackHash:e.hashCode(o.toString()),removeCb:e=>{const n=i.indexOf(a);if(-1!==n){const e=o.toString().slice(0,100);i.splice(n,1),console.log(`[DOM观察器] 回调移除成功: 函数片段=${e}，剩余回调数量=${i.length}`)}0===i.length&&(t.delete(r),e.disconnect(),console.log("[DOM观察器] 所有回调移除，观察器已断开。"))}};i.some((e=>e.callbackHash===a.callbackHash))?console.log("[DOM观察器] 已存在相同哈希值回调，未重复添加。"):(i.push(a),setTimeout((()=>a.removeCb(s)),c),console.log(`[DOM观察器] 添加回调，队列长度: ${i.length}`))}})(),throttleWithTail:(e,n)=>t(e,n),observeTarget:(e,t,o)=>new Promise(((r,c)=>{const{target:l}=t();if(l)try{r({target:l})}catch(e){console.error("[DOM观察器] onFound回调出错:",e),c(e)}else n.observeDOMChanges((({disconnect:e})=>{const{target:n}=t();if(n)try{r({target:n})}catch(e){console.error("[DOM观察器] onFound回调出错:",e),c(e)}finally{e()}}),e,{timeout:o})}))},o={findOne(e){const{selector:t,textContent:o,queriedDoc:r=document,observedDoc:c,timeout:l}=e;return n.observeTarget(c,(()=>{if(o){return{target:Array.from(r.querySelectorAll(t)).find((e=>{var t;return(null==(t=e.textContent)?void 0:t.trim())===o}))}}return{target:r.querySelector(t)}}),l)},findAll(e){const{selector:t,observedDoc:o,textContent:r,queriedDoc:c=document,timeout:l}=e;return n.observeTarget(o,(()=>{let e=Array.from(c.querySelectorAll(t));r&&(e=e.filter((e=>{var t;return(null==(t=e.textContent)?void 0:t.trim())===r})));return{target:(null==e?void 0:e.length)>0?e:null}}),l)},async clickOne(e){const t=e;let n=await this.findOne(t);const{target:o}=n;return o.click(),n},async clickAll(e){const t=e;let n=await this.findAll(t);const{target:o}=n;return o.forEach((e=>{e.click()})),n},async input(e){const t=e;let n=await this.findOne(t);const{target:o}=n;return o.value!==e.textInput&&(o.focus(),o.dispatchEvent(new Event("input",{bubbles:!0})),o.dispatchEvent(new Event("change",{bubbles:!0}))),n}};export{o as h};
